"""
Functions used in binding and selectivity analysis
"""
from .imports import importCITE, importReceptors
from .MBmodel import cytBindingModel_CITEseq, cytBindingModel_bispecCITEseq, cytBindingModel_bispecOpt, cytBindingModel_basicSelec
from os.path import dirname
from scipy.optimize import minimize, Bounds
import pandas as pd
import numpy as np

path_here = dirname(dirname(__file__))


def getSampleAbundances(epitopes: list, cellList: list, cellCat="CellType2"):
    """Given list of epitopes and cell types, returns a dataframe containing abundance data on a single cell level
    Args:
        epitopes: list of epitopes for which you want abundance values
        cellList: list of cell types for which you want epitope abundance

    Returns:
        epitopesDF: dataframe containing single cell abundances of epitopes(rows) for each cell type(columns).
        Each frame contains a list of size corresponding to representative sample of cell type
    """
    # This dataframe will later be filled with our epitope abundance by cells
    receptors = {'Epitope': epitopes}
    epitopesDF = pd.DataFrame(receptors)

    # Import CITE data
    CITE_DF = importCITE()

    # Get conv factors, average them to use on epitopes with unlisted conv facts
    convFact = convFactCalc()
    meanConv = convFact.Weight.mean()

    # Sample sizes generated corresponding to cell list using mean values
    sampleSizes = []
    for cellType in cellList:
        cellSample = []
        for i in np.arange(10):  # Averaging results of 10
            sampleDF = CITE_DF.sample(161000, random_state=42)  # Of 1000 cells in the sample...
            sampleSize = int(len(sampleDF.loc[sampleDF[cellCat] == cellType]))  # ...How many are this cell type
            cellSample.append(sampleSize)  # Sample size is equivalent to represented cell count out of 1000 cells
        meanSize = np.mean(cellSample)
        sampleSizes.append(int(meanSize))

    # For each  cellType in list
    for i, cellType in enumerate(cellList):
        # Generate sample size
        sampleSize = sampleSizes[i]
        # Create data frame of this size at random selection
        cellDF = CITE_DF.loc[CITE_DF[cellCat] == cellType].sample(sampleSize, random_state=42)

        cellType_abdundances = []
        # For each epitope (being done on per cell basis)
        for e in epitopesDF.Epitope:
            # calculate abundance based on converstion factor
            if e == 'CD25':
                convFact = 77.136987  # The values are from convFactCalc
            elif e == 'CD122':
                convFact = 332.680090
            elif e == "CD127":
                convFact = 594.379215
            else:
                convFact = meanConv

            # Calculating abundance from cite data
            citeVal = cellDF[e].to_numpy()  # Getting CITE signals for each cell
            abundance = citeVal * convFact  # (CITE signal * conversion factor) = abundance
            cellType_abdundances.append(abundance)  # Append abundances for individual cells into one list
            # add column with this name to epitopesDF and abundances list

        epitopesDF[cellType] = cellType_abdundances  # This list will be located at Epitope x Cell Type in the DF

    return epitopesDF


def getSignaling(betaAffs: np.ndarray, targCell: str, offTCells: list, epitopesDF: pd.DataFrame):
    """Returns total signaling summed over single cells for given parameters, can be adjusted for various purposes
    Args:
        betaAffs: 1D numpy array of beta receptor affinities over which to analyze signaling
        targCell: string Cell type which is target and signaling is desired (basis of selectivity)
        offTCells: list of strings of cell types for which signaling is undesired
        epitopesDF: contains info on epitope abundance by cell type (generated by getSampleAbundance())

    Returns:
        target_sigs: List of total on target signal (sum of single cells in sample). Each item in list corresponds
        to different modeling paradigm (Wild type signaler, mutein, different valency, etc.)
        offTarg_sigs:  List of total off target signal
    """

    target_sigs = np.zeros((8, betaAffs.size))  # 8 is used here because we are comparing 8 total signal types
    offTarg_sigs = np.zeros((8, betaAffs.size))

    # 0-2 IL2 WT
    # 3-5 R38Q
    # 6-7 Live/Dead
    muts = ['IL2', 'R38Q/H16N']
    vals = [1, 2, 4]

    for i, aff in enumerate(betaAffs):
        for j, mut in enumerate(muts):
            for k, val in enumerate(vals):
                n = (3 * j) + k
                target_sig, offTarg_sig = bindingCalc(epitopesDF, targCell, offTCells, aff, val, mut)
                target_sigs[n, i] = target_sig
                offTarg_sigs[n, i] = offTarg_sig

        target_sig_bi, offTarg_sig_bi = bindingCalc(epitopesDF, targCell, offTCells, aff, 1, 'R38Q/H16N', bispec=True, epitope='CD25')
        target_sigs[6, i] = target_sig_bi
        offTarg_sigs[6, i] = offTarg_sig_bi

        target_sig_bi, offTarg_sig_bi = bindingCalc(epitopesDF, targCell, offTCells, aff, 2, 'R38Q/H16N', bispec=True, epitope='CD25')
        target_sigs[7, i] = target_sig_bi
        offTarg_sigs[7, i] = offTarg_sig_bi

    return target_sigs, offTarg_sigs


def bindingCalc(df: pd.DataFrame, targCell: str, offTCells: list, betaAffs: np.ndarray, val: int, mut: str, bispec=False, epitope: str = None):
    """Calculates selectivity for no additional epitope
    Args:
        df: (epitopesDF) contains info on epitope abundance by cell type (generated by getSampleAbundance())
        targCell: string cell type which is target and signaling is desired (basis of selectivity)
        offTCells: list of strings of cell types for which signaling is undesired
        betaAffs: 1D numpy array of beta receptor affinities over which to analyze signaling
        val: desired valency of sigaling molecule
        mut: mutein signaling molecule name or wild type (dataset specific)
        bispec: if false, runs standard model...if true, runs bispecific signaling model
        epitope: REQUIRED if bispec=True, additional epitope to be targeted

    Returns:
        targetBound: total sum of signal generated by on target single cells as calculated by model
        offTargetBound: total sum of signal generated by off target single cells as calculated by model
    """
    targetBound = 0
    offTargetBound = 0

    cd25DF = df.loc[(df.Epitope == 'CD25')]
    cd122DF = df.loc[(df.Epitope == 'CD122')]

    if(bispec):
        epitopeDF = df.loc[(df.Epitope == epitope)]

        for i, cd25Count in enumerate(cd25DF[targCell].item()):
            cd122Count = cd122DF[targCell].item()[i]
            epitopeCount = epitopeDF[targCell].item()[i]
            counts = [cd25Count, cd122Count, epitopeCount]
            targetBound += cytBindingModel_bispecCITEseq(counts, betaAffs, 9.0, val, mut)

        for cellT in offTCells:
            for i, cd25Count in enumerate(cd25DF[cellT].item()):
                cd122Count = cd122DF[cellT].item()[i]
                epitopeCount = epitopeDF[cellT].item()[i]
                counts = [cd25Count, cd122Count, epitopeCount]
                offTargetBound += cytBindingModel_bispecCITEseq(counts, betaAffs, 9.0, val, mut)

    else:
        for i, cd25Count in enumerate(cd25DF[targCell].item()):
            cd122Count = cd122DF[targCell].item()[i]
            counts = [cd25Count, cd122Count]
            targetBound += cytBindingModel_CITEseq(counts, betaAffs, val, mut)

        for cellT in offTCells:
            for i, cd25Count in enumerate(cd25DF[cellT].item()):
                cd122Count = cd122DF[cellT].item()[i]
                counts = [cd25Count, cd122Count]
                offTargetBound += cytBindingModel_CITEseq(counts, betaAffs, val, mut)

    return targetBound, offTargetBound


def minSelecFunc(recXaff: np.ndarray, secondary: str, epitope: str, targRecs: np.ndarray, offTRecs: np.ndarray, dose: float, valency: int):
    """Serves as the function which will have its return value minimized to get optimal selectivity
    To be used in conjunction with optimizeDesign()
    Args:
        recXaff: receptor affinity which is modulated in optimize design

    Return:
        selectivity: value will be minimized, defined as ratio of off target to on target signaling
    """
    minSelecFunc.targetBound = 0
    offTargetBound = 0

    affs = np.power(10, recXaff)

    if secondary == 'CD122':
        if epitope == 'CD25':
            holder = np.full((3, 2), 1e2)
            holder[0, 0] = affs[0]
            holder[1, 1] = affs[1]
            holder[2, 0] = affs[2]
        else:
            holder = np.full((3, 3), 1e2)
            np.fill_diagonal(holder, affs)
    else:
        holder = np.full((2, 2), 1e2)
        np.fill_diagonal(holder, affs)

    targRecs = targRecs[0:holder.shape[1], :]
    offTRecs = offTRecs[0:holder.shape[1], :]

    for i in range(targRecs.shape[1]):
        minSelecFunc.targetBound += cytBindingModel_bispecOpt(targRecs[:, i], holder, dose, valency)
        offTargetBound += cytBindingModel_bispecOpt(offTRecs[:, i], holder, dose, valency)

    minSelecFunc.targetBound /= targRecs.shape[0]
    offTargetBound /= offTRecs.shape[0]

    return offTargetBound / minSelecFunc.targetBound


def optimizeDesign(secondary: str, epitope: str, targCell: str, offTCells: list, selectedDF: pd.DataFrame, dose: float, valency: int, prevOptAffs: list):
    """ A general purzse optimizer used to minimize selectivity output by varying affinity parameter.
    Args:
        targCell: string cell type which is target and signaling is desired (basis of selectivity)
        offTCells: list of strings of cell types for which signaling is undesired
        selectedDf: contains epitope abundance information by cell type
        epitope: additional epitope to be targeted

    Return:
        optSelectivity: optimized selectivity value. Can also be modified to return optimized affinity parameter.
     """
    X0 = prevOptAffs
    
    optBnds = Bounds(6.0, 9.0)
    targRecs, offTRecs = get_rec_vecs(selectedDF, targCell, offTCells, secondary, epitope)
    print('Optimize')
    optimized = minimize(minSelecFunc, X0, bounds=optBnds, args=(secondary, epitope, targRecs, offTRecs, dose, valency), jac="2-point")
    print('Done')
    optSelectivity = optimized.fun
    optParams = optimized.x

    return optSelectivity, optParams, minSelecFunc.targetBound


def selecCalc(df: pd.DataFrame, targCell: str, offTCells: list):
    """Calculates selectivity for no additional epitope
    Args:
        targCell: string cell type which is target and signaling is desired (basis of selectivity)
        offTCells: list of strings of cell types for which signaling is undesired
        df: contains epitope abundance information by cell type(importantly including cd25 anf cd122 here)
    Returns:
        selectivity value of standard IL2 based on abundances
    """
    targetBound = 0
    offTargetBound = 0

    cd25DF = df.loc[(df.Epitope == 'CD25')]
    cd122DF = df.loc[(df.Epitope == 'CD122')]
    targCellCount = 0
    offTCellCount = 0

    for i, cd25Count in enumerate(cd25DF[targCell].item()):
        cd122Count = cd122DF[targCell].item()[i]
        counts = [cd25Count, cd122Count]
        targetBound += cytBindingModel_basicSelec(counts)
        targCellCount += 1
    for cellT in offTCells:
        for i, cd25Count in enumerate(cd25DF[cellT].item()):
            cd122Count = cd122DF[cellT].item()[i]
            counts = [cd25Count, cd122Count]
            offTargetBound += cytBindingModel_basicSelec(counts)
            offTCellCount += 1
    print(offTCellCount)
    print(targCellCount)

    return (offTargetBound / offTCellCount) / (targetBound / targCellCount)


cellDict = {"CD4 Naive": "Thelper",
            "CD4 CTL": "Thelper",
            "CD4 TCM": "Thelper",
            "CD4 TEM": "Thelper",
            "NK": "NK",
            "CD8 Naive": "CD8",
            "CD8 TCM": "CD8",
            "CD8 TEM": "CD8",
            "Treg": "Treg"}


markDict = {"CD25": "IL2Ra",
            "CD122": "IL2Rb",
            "CD127": "IL7Ra",
            "CD132": "gc"}


def convFactCalc():
    """Returns conversion factors by marker for converting CITEseq signal into abundance"""
    CITE_DF = importCITE()
    cellToI = ["CD4 TCM", "CD8 Naive", "NK", "CD8 TEM", "CD4 Naive", "CD4 CTL", "CD8 TCM", "Treg", "CD4 TEM"]
    markers = ["CD122", "CD127", "CD25"]
    markerDF = pd.DataFrame(columns=["Marker", "Cell Type", "Amount", "Number"])
    for marker in markers:
        for cell in cellToI:
            cellTDF = CITE_DF.loc[CITE_DF["CellType2"] == cell][marker]
            markerDF = pd.concat([markerDF, pd.DataFrame({"Marker": [marker], "Cell Type": cell, "Amount": cellTDF.mean(), "Number": cellTDF.size})])

    markerDF = markerDF.replace({"Marker": markDict, "Cell Type": cellDict})
    markerDFw = pd.DataFrame(columns=["Marker", "Cell Type", "Average"])
    for marker in markerDF.Marker.unique():
        for cell in markerDF["Cell Type"].unique():
            subDF = markerDF.loc[(markerDF["Cell Type"] == cell) & (markerDF["Marker"] == marker)]
            wAvg = np.sum(subDF.Amount.values * subDF.Number.values) / np.sum(subDF.Number.values)
            markerDFw = pd.concat([markerDFw, pd.DataFrame({"Marker": [marker], "Cell Type": cell, "Average": wAvg})])

    recDF = importReceptors()
    weightDF = pd.DataFrame(columns=["Receptor", "Weight"])

    for rec in markerDFw.Marker.unique():
        CITEval = np.array([])
        Quantval = np.array([])
        for cell in markerDF["Cell Type"].unique():
            CITEval = np.concatenate((CITEval, markerDFw.loc[(markerDFw["Cell Type"] == cell) & (markerDFw["Marker"] == rec)].Average.values))
            Quantval = np.concatenate((Quantval, recDF.loc[(recDF["Cell Type"] == cell) & (recDF["Receptor"] == rec)].Mean.values))
        weightDF = pd.concat([weightDF, pd.DataFrame({"Receptor": [rec], "Weight": np.linalg.lstsq(np.reshape(CITEval, (-1, 1)).astype(float), Quantval, rcond=None)[0]})])
    return weightDF


def get_rec_vecs(df: pd.DataFrame, targCell: str, offTCells: list, secondary: str, epitope: str):
    """Returns vector of target and off target receptors"""
    cd25DF = df.loc[(df.Epitope == 'CD25')]
    secondaryDF = df.loc[(df.Epitope == secondary)]
    if secondary == 'CD122':
        df2 = df.loc[(df.Epitope == epitope)]
    else:
        df2 = df.loc[(df.Epitope == 'CD25')]

    cd25CountTarg = np.zeros(df2[targCell].item().size)
    secondaryCountTarg = np.zeros(df2[targCell].item().size)
    epCountvecTarg = np.zeros(df2[targCell].item().size)
    for i, epCount in enumerate(df2[targCell].item()):
        cd25CountTarg[i] = cd25DF[targCell].item()[i]
        secondaryCountTarg[i] = secondaryDF[targCell].item()[i]
        epCountvecTarg[i] = epCount
    
    cd25CountOffT = np.array([])
    secondaryCountOffT = np.array([])
    epCountvecOffT = np.array([])
    for cellT in offTCells:
        for i, epCount in enumerate(df2[cellT].item()):
            cd25CountOffT = np.append(cd25CountOffT, cd25DF[cellT].item()[i])
            secondaryCountOffT = np.append(secondaryCountOffT, secondaryDF[cellT].item()[i])
            epCountvecOffT = np.append(epCountvecOffT, epCount)

    return np.array([cd25CountTarg, secondaryCountTarg, epCountvecTarg]), np.array([cd25CountOffT, secondaryCountOffT, epCountvecOffT])


def get_cell_bindings(affs: np.ndarray, cells: np.ndarray, df: pd.DataFrame, secondary: str, epitope: str, dose: float, valency: int):
    df_return = pd.DataFrame(columns=['Cell Type', 'Secondary Bound', 'Total Secondary'])

    cd25DF = df.loc[(df.Epitope == 'CD25')]
    secondaryDF = df.loc[(df.Epitope == secondary)]
    if secondary == 'CD122':
        df2 = df.loc[(df.Epitope == epitope)]
    else:
        df2 = df.loc[(df.Epitope == 'CD25')]

    for cell in cells:
        numCells = df2[cell].item().size

        cd25CountTarg = np.zeros(numCells)
        secondaryCountTarg = np.zeros(numCells)
        epCountvecTarg = np.zeros(numCells)
        for i, epCount in enumerate(df2[cell].item()):
            cd25CountTarg[i] = cd25DF[cell].item()[i]
            secondaryCountTarg[i] = secondaryDF[cell].item()[i]
            epCountvecTarg[i] = epCount

        recs = np.array([cd25CountTarg, secondaryCountTarg, epCountvecTarg])

        secondaryBound = 0.0
        for i in range(recs.shape[1]):
            secondaryBound += cytBindingModel_bispecOpt(recs[:, i], affs[0:3], dose, valency)

        data = {'Cell Type': [cell],
            'Secondary Bound': [secondaryBound / numCells],
            'Total Secondary': [np.sum(recs[1]) / numCells]
        }

        print(data)

        df_temp = pd.DataFrame(data, columns=['Cell Type', 'Secondary Bound', 'Total Secondary'])
        df_return = df_return.append(df_temp, ignore_index=True)
    
    return df_return

