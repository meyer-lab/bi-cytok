---
title: "Relationship between 2D distance metrics and 3D selectivity"
---

# Summary
Generates scatter plots examining the correlation between 2D distance metrics (KL Divergence and EMD) and 3D selectivity optimization results for receptor pairs. Evaluates whether pairwise receptor distribution differences predict multivalent complex selectivity performance.

# Imports
- CITE-seq surface marker expression data (`importCITE`)
- 2D distance metric calculation functions (`KL_EMD_2D`)
- Selectivity optimization functions (`optimize_affs`)

# Parameters
- `receptor_pairs`: List of 2-element lists specifying receptor pairs for distance metric calculations and to be used as target receptors in selectivity optimization
- `signal_receptor`: String name of receptor used for signal delivery in binding model
- `sample_size`: Integer number of cells sampled from CITE-seq data for analysis
- `targ_cell`: String identifier for target cell type in selectivity optimization
- `dose`: Float concentration of ligand complex in binding model
- `cell_categorization`: String column name for cell type classification in CITE-seq data
- `model_valencies`: 2D numpy array specifying tetravalent complex design [[signal, target1, target2]]

# Outputs
- **Scatter Plot 1**: 2D KL Divergence vs 3D selectivity showing:
  - KL Divergence values on x-axis
  - Selectivity values (1/optimization_result) on y-axis
  - Color-coded points by receptor pair combination
  - Legend identifying each receptor pair
- **Scatter Plot 2**: 2D EMD vs 3D selectivity with identical formatting

```{python}
%config InlineBackend.figure_formats = ['svg']

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

from bicytok.distance_metric_funcs import KL_EMD_2D
from bicytok.imports import filter_receptor_abundances, importCITE, sample_receptor_abundances
from bicytok.selectivity_funcs import optimize_affs

import time

receptors = ["CD25", "CD4-1", "CD27", "CD338"]
# receptors = None
signal_receptor = "CD122"
sample_size = 1000
targ_cell = "Treg"
dose = 1e-10
cell_categorization = "CellType2"
model_valencies_main = np.array([[2, 2]])
model_valencies_diag = np.array([[2, 1, 1]])

def generate_receptor_pairs(receptors):
    pairs = []
    for r1 in receptors:
        for r2 in receptors:
            pairs.append([r1, r2])
    return pairs

CITE_DF = importCITE()
assert targ_cell in CITE_DF[cell_categorization].unique()

epitopes = [
    col
    for col in CITE_DF.columns
    if col not in ["CellType1", "CellType2", "CellType3"]
]

epitopes_df = CITE_DF[epitopes + [cell_categorization]]
epitopes_df = epitopes_df.rename(columns={cell_categorization: "Cell Type"})
sample_df = sample_receptor_abundances(
    CITE_DF=epitopes_df,
    numCells=min(sample_size, epitopes_df.shape[0]),
    targCellType=targ_cell,
)

if receptors is not None:
    filtered_sample_df = filter_receptor_abundances(sample_df, targ_cell, whitelist=receptors)
    receptor_pairs = generate_receptor_pairs(receptors)
else:
    filtered_sample_df = filter_receptor_abundances(sample_df, targ_cell)
    receptors = [
        col
        for col in filtered_sample_df.columns
        if col != "Cell Type"
    ]
    receptor_pairs = generate_receptor_pairs(receptors)

print(f"Receptors analyzed: {receptors}")

on_target_mask = (filtered_sample_df["Cell Type"] == targ_cell).to_numpy()
off_target_mask = ~on_target_mask

df_targ_cell = filtered_sample_df.loc[on_target_mask]
df_off_targ_cell = filtered_sample_df.loc[off_target_mask]

selectivity_vals = []
KL_div_vals = []
EMD_vals = []
for i, receptor_pair in enumerate(receptor_pairs):
    time_start = time.time()

    rec_abundances = filtered_sample_df[receptor_pair].to_numpy()

    time_start_metric = time.time()
    KL_div_mat, EMD_mat = KL_EMD_2D(
        rec_abundances, on_target_mask, off_target_mask, calc_1D=False
    )
    KL_div = KL_div_mat[1, 0]
    EMD = EMD_mat[1, 0]
    KL_div_vals.append(KL_div)
    EMD_vals.append(EMD)
    print(f"Metric calculation time for {receptor_pair}: {time.time() - time_start_metric} seconds")

    time_start_opt = time.time()
    if receptor_pair[0] == receptor_pair[1]:
        model_valencies = model_valencies_diag
        # targ_recs = df_targ_cell[[signal_receptor] + [receptor_pair[0]]].to_numpy()
        # off_targ_recs = df_off_targ_cell[[signal_receptor] + [receptor_pair[0]]].to_numpy()
        targ_recs = df_targ_cell[[signal_receptor, receptor_pair[0], receptor_pair[0]]].to_numpy()
        off_targ_recs = df_off_targ_cell[[signal_receptor, receptor_pair[0], receptor_pair[0]]].to_numpy()
    else:
        model_valencies = model_valencies_main
        targ_recs = df_targ_cell[[signal_receptor] + receptor_pair].to_numpy()
        off_targ_recs = df_off_targ_cell[[signal_receptor] + receptor_pair].to_numpy()

    opt_selec, opt_affs, opt_Kx_star = optimize_affs(
        targRecs=targ_recs,
        offTargRecs=off_targ_recs,
        dose=dose,
        valencies=model_valencies,
        max_iter=1000,
        tol=1e-9,
    )
    selectivity_vals.append(1 / opt_selec)
    print(f"Optimization time for {receptor_pair}: {time.time() - time_start_opt} seconds")

    time_end = time.time()
    print(f"Processing time for {receptor_pair}, pair {i} out of {len(receptor_pairs)}: {time_end - time_start} seconds")
    print(f"Affinities: {opt_affs}, Kx*: {opt_Kx_star}\n\n\n")

metrics_df = pd.DataFrame(
    {
        "Receptor Pair": [str(receptor) for receptor in receptor_pairs],
        "KL Divergence": KL_div_vals,
        "EMD": EMD_vals,
        "Selectivity": selectivity_vals,
    }
)
```

```{python}
#| fig-cap: "KL Divergence vs Selectivity for receptor pairs"

def label_top_n(ax, data, x_col, y_col, n=10):
    """Label top n points by y-value on scatter plot."""
    top_indices_y = data.nlargest(n, y_col).index
    for idx in top_indices_y:
        ax.annotate(
            data.loc[idx, "Receptor Pair"],
            (data.loc[idx, x_col], data.loc[idx, y_col]),
            fontsize=8,
            alpha=0.7,
            xytext=(5, 5),
            textcoords="offset points"
        )
    
    top_indices_x = data.nlargest(n, x_col).index
    for idx in top_indices_x:
        if idx not in top_indices_y:
            ax.annotate(
                data.loc[idx, "Receptor Pair"],
                (data.loc[idx, x_col], data.loc[idx, y_col]),
                fontsize=8,
                alpha=0.7,
                xytext=(5, 5),
                textcoords="offset points"
            )

fig, ax = plt.subplots(figsize=(10, 6))
sns.scatterplot(
    data=metrics_df,
    x="KL Divergence",
    y="Selectivity",
    hue="Receptor Pair",
    s=70,
    legend=False,
    ax=ax,
)

label_top_n(ax, metrics_df, "KL Divergence", "Selectivity", n=5)
ax.grid(True, linestyle='--', alpha=0.7)
ax.legend(bbox_to_anchor=(1.05, 1), title="Receptor Pair")
plt.tight_layout()
plt.show()
```

```{python}
#| fig-cap: "EMD vs Selectivity for receptor pairs"

fig, ax = plt.subplots(figsize=(10, 6))
sns.scatterplot(
    data=metrics_df,
    x="EMD",
    y="Selectivity",
    hue="Receptor Pair",
    s=70,
    legend=False,
    ax=ax,
)

label_top_n(ax, metrics_df, "EMD", "Selectivity", n=5)
ax.grid(True, linestyle='--', alpha=0.7)
ax.legend(bbox_to_anchor=(1.05, 1), title="Receptor Pair")
plt.tight_layout()
plt.show()
```

## Parameter Summary
```{python}
#| output: asis

text = f"""
Visualized the relationship between 2D distance metrics (KL Divergence and EMD) and 3D selectivity. Target cells were **{targ_cell}**s, compared against all other cell types. The analysis was performed on **{sample_size}** cells sampled from the CITE-seq dataset.
\n\n
For selectivity optimization, the signal receptor was **{signal_receptor}**, with tetravalent complexes at a dose of **{dose}**. Tetravalent complexes consisted of two signal receptor ligands, and one ligand each for the two target receptors. The epitope pairs that were analyzed were **{', '.join(map(str, receptor_pairs))}**, which served as the target receptors for selectivity optimization and as the double receptor distributions for 2D EMD and KL div. calculations.
"""

print(text)
```