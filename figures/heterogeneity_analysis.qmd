---
title: "Selectivity and Cell-to-Cell Heterogeneity Analysis"
format:
  html:
    code-fold: false
jupyter: python3
---

# Summary

Investigates how selectivity optimization accounts for cell-to-cell heterogeneity by analyzing bound receptor distributions across cell populations for pre-specified receptor combinations. Examines whether optimized selectivity combinations are biased toward high-expression cells and how the population-level selectivity metric relates to single-cell binding heterogeneity.

# Imports

- CITE-seq surface marker expression data (`importCITE`)
- Selectivity optimization and binding calculation functions (`optimize_affs`, `get_cell_bindings`)
- Statistical and visualization libraries

# Parameters

- `signal_receptor`: String name of receptor used for signal delivery in binding model
- `target_receptors`: List of target receptor combinations to analyze
- `targ_cell`: String identifier for target cell type in selectivity analysis
- `sample_size`: Integer number of cells sampled from CITE-seq data for analysis
- `dose`: Float concentration of ligand complex in binding model
- `cell_categorization`: String column name for cell type classification in CITE-seq data

# Outputs

- **Distribution Plots**: Histograms and violin plots showing bound receptor distributions for target vs off-target cells
- **Correlation Analysis**: Scatter plots examining relationship between receptor expression levels and bound receptors
- **Heterogeneity Metrics**: Quantitative measures of binding heterogeneity within cell populations
- **Bias Analysis**: Assessment of whether high-expression cells disproportionately contribute to selectivity

```{python}
%config InlineBackend.figure_formats = ['svg']

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from scipy import stats
from scipy.stats import pearsonr, spearmanr

from bicytok.imports import importCITE, sample_receptor_abundances, filter_receptor_abundances
from bicytok.selectivity_funcs import optimize_affs, get_cell_bindings

plt.rcParams["svg.fonttype"] = "none"
plt.style.use('default')

# Analysis parameters
signal_receptor = "CD122"

# Define receptor combinations with explicit valency specifications
# Each entry: (receptor_list, valency_array, description)
receptor_combinations = [
    (["CD25"], np.array([[2, 1]]), "CD25 x1 (single receptor, monovalent)"),
    (["CD25"], np.array([[2, 2]]), "CD25 x2 (single receptor, bivalent)"),
    (["CD4-1"], np.array([[2, 2]]), "CD4-1 x2 (single receptor, bivalent)"),
    (["CD27"], np.array([[2, 2]]), "CD27 x2 (single receptor, bivalent)"),
    (["CD25", "CD4-1"], np.array([[2, 1, 1]]), "CD25 + CD4-1 (dual receptor)"),
    (["CD25", "CD27"], np.array([[2, 1, 1]]), "CD25 + CD27 (dual receptor)"),
]

targ_cell = "Treg"
sample_size = 1000
dose = 1e-10
cell_categorization = "CellType2"

# Load and prepare data
CITE_DF = importCITE()
assert targ_cell in CITE_DF[cell_categorization].unique()

epitopes = [
    col
    for col in CITE_DF.columns
    if col not in ["CellType1", "CellType2", "CellType3"]
]
epitopes_df = CITE_DF[epitopes + [cell_categorization]]
epitopes_df = epitopes_df.rename(columns={cell_categorization: "Cell Type"})

sample_df = sample_receptor_abundances(
    CITE_DF=epitopes_df,
    numCells=min(sample_size, epitopes_df.shape[0]),
    targCellType=targ_cell,
)

filtered_sample_df = filter_receptor_abundances(sample_df, targ_cell)

# Create masks for target and off-target cells
targ_mask = (filtered_sample_df["Cell Type"] == targ_cell).to_numpy()
off_targ_mask = ~targ_mask

print(f"Analyzing {np.sum(targ_mask)} target cells and {np.sum(off_targ_mask)} off-target cells")
print(f"Target cell type: {targ_cell}")
print(f"Signal receptor: {signal_receptor}")
print(f"Dose: {dose}")
```

```{python}
# Function to analyze binding heterogeneity for a given receptor combination
def analyze_binding_heterogeneity(target_recs, valencies, signal_receptor, sample_df, targ_mask, off_targ_mask, dose, description=""):
    """
    Analyze binding heterogeneity for a specific receptor combination
    
    Args:
        target_recs: List of target receptor names
        valencies: Numpy array specifying valencies for [signal, target1, target2, ...]
        signal_receptor: Name of signal receptor
        sample_df: DataFrame with cell data
        targ_mask: Boolean mask for target cells
        off_targ_mask: Boolean mask for off-target cells  
        dose: Ligand concentration
        description: Human-readable description of the combination
        
    Returns:
        dict containing analysis results
    """
    
    # Prepare receptor combination data
    all_recs = [signal_receptor] + target_recs
    rec_data = sample_df[all_recs + ["Cell Type"]].copy()
    
    # Create receptor count arrays
    targ_rec_counts = rec_data.loc[targ_mask, all_recs].to_numpy()
    off_targ_rec_counts = rec_data.loc[off_targ_mask, all_recs].to_numpy()
    
    # Use provided valencies
    print(f"  Using valencies: {valencies[0]} for receptors: {all_recs}")
    
    # Optimize affinities
    opt_selec, opt_affs, opt_kx_star = optimize_affs(
        targRecs=targ_rec_counts,
        offTargRecs=off_targ_rec_counts,
        dose=dose,
        valencies=valencies,
    )
    
    # Calculate bound receptors for each cell using optimized parameters
    all_rec_counts = rec_data[all_recs].to_numpy()
    bound_recs = get_cell_bindings(
        recCounts=all_rec_counts,
        monomerAffs=opt_affs,
        dose=dose,
        valencies=valencies,
        Kx_star=opt_kx_star,
    )
    
    # Extract signal receptor binding (first column)
    signal_bound = bound_recs[:, 0]
    
    # Split into target and off-target
    targ_signal_bound = signal_bound[targ_mask]
    off_targ_signal_bound = signal_bound[off_targ_mask]
    
    # Calculate heterogeneity metrics
    targ_cv = np.std(targ_signal_bound) / np.mean(targ_signal_bound) if np.mean(targ_signal_bound) > 0 else 0
    off_targ_cv = np.std(off_targ_signal_bound) / np.mean(off_targ_signal_bound) if np.mean(off_targ_signal_bound) > 0 else 0
    
    # Calculate correlation between expression and binding
    signal_expr = rec_data[signal_receptor].to_numpy()
    targ_signal_expr = signal_expr[targ_mask]
    off_targ_signal_expr = signal_expr[off_targ_mask]
    
    targ_corr, targ_p = pearsonr(targ_signal_expr, targ_signal_bound) if len(targ_signal_expr) > 1 else (0, 1)
    off_targ_corr, off_targ_p = pearsonr(off_targ_signal_expr, off_targ_signal_bound) if len(off_targ_signal_expr) > 1 else (0, 1)
    
    # Calculate bias toward high-expression cells
    # Define high-expression as top quartile
    targ_expr_q75 = np.percentile(targ_signal_expr, 75)
    targ_high_expr_mask = targ_signal_expr >= targ_expr_q75
    
    # Calculate fraction of total binding from high-expression cells
    targ_high_expr_binding_frac = np.sum(targ_signal_bound[targ_high_expr_mask]) / np.sum(targ_signal_bound) if np.sum(targ_signal_bound) > 0 else 0
    
    # Expected fraction if binding were uniform (should be ~0.25 if no bias)
    targ_high_expr_cell_frac = np.mean(targ_high_expr_mask)
    
    results = {
        'receptor_combo': target_recs,
        'valencies': valencies,
        'description': description,
        'selectivity': 1 / opt_selec,
        'opt_affs': opt_affs,
        'opt_kx_star': opt_kx_star,
        'targ_bound': targ_signal_bound,
        'off_targ_bound': off_targ_signal_bound,
        'targ_expr': targ_signal_expr,
        'off_targ_expr': off_targ_signal_expr,
        'targ_cv': targ_cv,
        'off_targ_cv': off_targ_cv,
        'targ_corr': targ_corr,
        'targ_corr_p': targ_p,
        'off_targ_corr': off_targ_corr,
        'off_targ_corr_p': off_targ_p,
        'high_expr_binding_frac': targ_high_expr_binding_frac,
        'high_expr_cell_frac': targ_high_expr_cell_frac,
        'binding_bias_ratio': targ_high_expr_binding_frac / targ_high_expr_cell_frac if targ_high_expr_cell_frac > 0 else 0,
        'all_bound': bound_recs,
        'all_mask': np.concatenate([targ_mask, off_targ_mask]),
    }
    
    return results

# Analyze all receptor combinations with explicit valencies
results_list = []
for target_combo, valencies, description in receptor_combinations:
    print(f"Analyzing combination: {signal_receptor} + {target_combo}")
    print(f"Description: {description}")
    try:
        result = analyze_binding_heterogeneity(
            target_combo, valencies, signal_receptor, filtered_sample_df, 
            targ_mask, off_targ_mask, dose, description
        )
        results_list.append(result)
        print(f"  Selectivity: {result['selectivity']:.2f}")
        print(f"  Target CV: {result['targ_cv']:.3f}")
        print(f"  Binding bias ratio: {result['binding_bias_ratio']:.2f}")
    except Exception as e:
        print(f"  Error: {e}")
        import traceback
        traceback.print_exc()
    print()

print(f"Successfully analyzed {len(results_list)} combinations")
```

```{python}
# Create focused visualization of bound signal receptor distributions
fig, axes = plt.subplots(2, 3, figsize=(18, 10))
fig.suptitle('Bound Signal Receptor Distributions: Target vs Off-Target Cells', fontsize=16, fontweight='bold')

# Colors for consistent visualization
colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']

# Plot individual histograms for each combination
for i, result in enumerate(results_list):
    row = i // 3
    col = i % 3
    
    if row < 2 and col < 3:  # Only plot if we have space
        ax = axes[row, col]
        
        combo_name = "+".join(result['receptor_combo'])
        valency_str = f"[{', '.join(map(str, result['valencies'][0]))}]"
        
        # Calculate robust range to focus on main cluster (remove outliers for visualization)
        all_data = np.concatenate([result['targ_bound'], result['off_targ_bound']])
        q1, q3 = np.percentile(all_data, [25, 75])
        iqr = q3 - q1
        lower_bound = max(0, q1 - 1.5 * iqr)  # Don't go below 0
        upper_bound = q3 + 1.5 * iqr
        
        # Filter data for main cluster visualization
        targ_main = result['targ_bound'][(result['targ_bound'] >= lower_bound) & 
                                        (result['targ_bound'] <= upper_bound)]
        off_main = result['off_targ_bound'][(result['off_targ_bound'] >= lower_bound) & 
                                           (result['off_targ_bound'] <= upper_bound)]
        
        # Set consistent bins based on filtered range
        bins = np.linspace(lower_bound, upper_bound, 25)
        
        # Plot target cells (solid) - main cluster only
        ax.hist(targ_main, bins=bins, alpha=0.7, 
                label=f'Target main cluster (n={len(targ_main)}/{len(result["targ_bound"])})', 
                density=True, color=colors[i], edgecolor='black', linewidth=0.5)
        
        # Plot off-target cells (hatched) - main cluster only
        ax.hist(off_main, bins=bins, alpha=0.5,
                label=f'Off-target main cluster (n={len(off_main)}/{len(result["off_targ_bound"])})', 
                density=True, color=colors[i], edgecolor='black', 
                linewidth=0.5, hatch='///')
        
        # Add mean lines (still use all data for means)
        targ_mean = np.mean(result['targ_bound'])
        off_mean = np.mean(result['off_targ_bound'])
        
        # Only show mean lines if they're within the visible range
        if lower_bound <= targ_mean <= upper_bound:
            ax.axvline(targ_mean, color='blue', linestyle='-', linewidth=2, 
                       label=f'Target mean: {targ_mean:.2f}')
        if lower_bound <= off_mean <= upper_bound:
            ax.axvline(off_mean, color='red', linestyle='--', linewidth=2,
                       label=f'Off-target mean: {off_mean:.2f}')
        
        # Set x-axis limits to focus on main cluster
        ax.set_xlim(lower_bound, upper_bound)
        
        # Labels and title
        ax.set_xlabel(f'{signal_receptor} Bound (molecules)')
        ax.set_ylabel('Density')
        ax.set_title(f'{combo_name} {valency_str}\nSelectivity: {result["selectivity"]:.2f}')
        ax.legend(fontsize=7, loc='upper right')
        
        # Add statistics text box with outlier information
        n_targ_outliers = len(result['targ_bound']) - len(targ_main)
        n_off_outliers = len(result['off_targ_bound']) - len(off_main)
        
        stats_text = f'Target: μ={targ_mean:.2f}, σ={np.std(result["targ_bound"]):.2f}\n'
        stats_text += f'Off-target: μ={off_mean:.2f}, σ={np.std(result["off_targ_bound"]):.2f}\n'
        if n_targ_outliers > 0 or n_off_outliers > 0:
            stats_text += f'Outliers: {n_targ_outliers}T, {n_off_outliers}O'
        
        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes, 
                verticalalignment='top', fontsize=7, 
                bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

# Hide any unused subplots
for i in range(len(results_list), 6):
    row = i // 3
    col = i % 3
    if row < 2 and col < 3:
        axes[row, col].set_visible(False)

plt.tight_layout()
plt.show()
```

```{python}
# Create side-by-side comparison and violin plots for clearer visualization
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

# Left panel: Side-by-side violin plots showing all combinations with outlier handling
violin_positions = []
violin_data = []
violin_labels = []
colors_expanded = []

position = 0
for i, result in enumerate(results_list):
    combo_name = "+".join(result['receptor_combo'])
    
    # Calculate robust range for this combination
    all_data = np.concatenate([result['targ_bound'], result['off_targ_bound']])
    q1, q3 = np.percentile(all_data, [25, 75])
    iqr = q3 - q1
    lower_bound = max(0, q1 - 1.5 * iqr)
    upper_bound = q3 + 1.5 * iqr
    
    # Clip outliers for better visualization (keep statistical info)
    targ_clipped = np.clip(result['targ_bound'], lower_bound, upper_bound)
    off_clipped = np.clip(result['off_targ_bound'], lower_bound, upper_bound)
    
    # Target cells
    violin_data.append(targ_clipped)
    violin_positions.append(position)
    violin_labels.append(f"{combo_name}\nTarget")
    colors_expanded.append('lightblue')
    position += 1
    
    # Off-target cells
    violin_data.append(off_clipped)
    violin_positions.append(position)  
    violin_labels.append(f"{combo_name}\nOff-target")
    colors_expanded.append('lightcoral')
    position += 1.5  # Gap between combinations

# Create violin plots
parts = ax1.violinplot(violin_data, positions=violin_positions, widths=0.8, showmeans=True, showmedians=True)

# Color the violins
for i, (pc, color) in enumerate(zip(parts['bodies'], colors_expanded)):
    pc.set_facecolor(color)
    pc.set_alpha(0.7)
    if 'Target' in violin_labels[i]:
        pc.set_edgecolor('blue')
    else:
        pc.set_edgecolor('red')

ax1.set_xticks(violin_positions)
ax1.set_xticklabels(violin_labels, rotation=45, ha='right', fontsize=8)
ax1.set_ylabel(f'{signal_receptor} Bound (molecules)')
ax1.set_title('Signal Receptor Binding Distributions\n(Violin plots with outliers clipped for clarity)')
ax1.grid(axis='y', alpha=0.3)

# Add outlier handling note
outlier_note = 'Note: Outliers beyond 1.5×IQR clipped for visualization\nMeans/medians from full data'
ax1.text(0.02, 0.02, outlier_note, transform=ax1.transAxes, 
         fontsize=8, bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.8))

# Add legend
from matplotlib.patches import Patch
legend_elements = [Patch(facecolor='lightblue', edgecolor='blue', label='Target cells'),
                   Patch(facecolor='lightcoral', edgecolor='red', label='Off-target cells')]
ax1.legend(handles=legend_elements, loc='upper right')

# Right panel: Summary metrics that directly relate to selectivity calculation
combo_names = ["+".join(r['receptor_combo']) for r in results_list]
target_means = [np.mean(r['targ_bound']) for r in results_list]
off_target_means = [np.mean(r['off_targ_bound']) for r in results_list]
selectivities = [r['selectivity'] for r in results_list]

x_pos = np.arange(len(combo_names))
width = 0.35

bars1 = ax2.bar(x_pos - width/2, target_means, width, label='Target mean binding', 
                alpha=0.8, color='blue', edgecolor='darkblue')
bars2 = ax2.bar(x_pos + width/2, off_target_means, width, label='Off-target mean binding', 
                alpha=0.8, color='red', edgecolor='darkred')

# Add selectivity values as text
for i, (sel, targ_mean, off_mean) in enumerate(zip(selectivities, target_means, off_target_means)):
    max_bar_height = max(targ_mean, off_mean)
    ax2.text(i, max_bar_height + 0.05, f'S={sel:.2f}', 
             ha='center', va='bottom', fontweight='bold', fontsize=9)

ax2.set_xlabel('Receptor Combination')
ax2.set_ylabel(f'{signal_receptor} Mean Binding')
ax2.set_title('Mean Binding Values Used in Selectivity Calculation\n(S = Selectivity = Target Mean / Off-target Mean)')
ax2.set_xticks(x_pos)
ax2.set_xticklabels(combo_names, rotation=45, ha='right')
ax2.legend()
ax2.grid(axis='y', alpha=0.3)

plt.tight_layout()
plt.show()
```

```{python}
# Print key metrics that directly relate to selectivity calculation
print("=== SELECTIVITY CALCULATION BREAKDOWN ===\n")

print("The selectivity metric is calculated as:")
print("Selectivity = (Mean Target Binding) / (Mean Off-target Binding)")
print("where binding refers to bound signal receptors (CD122) per cell\n")

for i, result in enumerate(results_list):
    combo_name = "+".join(result['receptor_combo'])
    valency_str = f"[{', '.join(map(str, result['valencies'][0]))}]"
    
    target_mean = np.mean(result['targ_bound'])
    off_target_mean = np.mean(result['off_targ_bound'])
    
    print(f"{combo_name} {valency_str}:")
    print(f"  Description: {result['description']}")
    print(f"  Target cells: {target_mean:.3f} ± {np.std(result['targ_bound']):.3f} bound {signal_receptor}/cell")
    print(f"  Off-target cells: {off_target_mean:.3f} ± {np.std(result['off_targ_bound']):.3f} bound {signal_receptor}/cell")  
    print(f"  Selectivity: {target_mean:.3f} / {off_target_mean:.3f} = {result['selectivity']:.3f}")
    print(f"  Target cell range: {np.min(result['targ_bound']):.3f} to {np.max(result['targ_bound']):.3f}")
    print(f"  Off-target cell range: {np.min(result['off_targ_bound']):.3f} to {np.max(result['off_targ_bound']):.3f}")
    print()

print("=== KEY OBSERVATIONS ===\n")

print("VALENCY SPECIFICATIONS:")
for result in results_list:
    combo_name = "+".join(result['receptor_combo'])
    valency_str = f"[{', '.join(map(str, result['valencies'][0]))}]"
    all_recs = [signal_receptor] + result['receptor_combo']
    print(f"  {combo_name}: {valency_str} → {', '.join([f'{v}x{r}' for v, r in zip(result['valencies'][0], all_recs)])}")

print()

# Compare single vs dual receptor combinations
single_receptor_results = [r for r in results_list if r['receptor_combo'][0] == r['receptor_combo'][1]]
dual_receptor_results = [r for r in results_list if r['receptor_combo'][0] != r['receptor_combo'][1]]

if single_receptor_results:
    print("SINGLE RECEPTOR COMBINATIONS:")
    for result in single_receptor_results:
        combo_name = result['receptor_combo'][0]  # Same receptor twice
        print(f"  {combo_name} (bivalent): Selectivity = {result['selectivity']:.3f}")

if dual_receptor_results:
    print("\nDUAL RECEPTOR COMBINATIONS:")
    for result in dual_receptor_results:
        combo_name = "+".join(result['receptor_combo'])
        print(f"  {combo_name} (monovalent each): Selectivity = {result['selectivity']:.3f}")

print(f"\nAll combinations use consistent total valency with 2x {signal_receptor} signal receptor")
print("This ensures fair comparison between single and dual receptor strategies.")
```

```{python}
# Show raw distribution data as a table for transparency
print("=== RAW DISTRIBUTION DATA ===\n")

print("Distribution statistics for bound signal receptors:")
print("(This is the raw data that feeds into the selectivity calculation)\n")

# Create a summary table
data_rows = []
for result in results_list:
    combo_name = "+".join(result['receptor_combo'])
    
    # Target cell statistics
    targ_stats = {
        'n': len(result['targ_bound']),
        'mean': np.mean(result['targ_bound']),
        'std': np.std(result['targ_bound']),
        'median': np.median(result['targ_bound']),
        'q25': np.percentile(result['targ_bound'], 25),
        'q75': np.percentile(result['targ_bound'], 75)
    }
    
    # Off-target cell statistics  
    off_stats = {
        'n': len(result['off_targ_bound']),
        'mean': np.mean(result['off_targ_bound']),
        'std': np.std(result['off_targ_bound']),
        'median': np.median(result['off_targ_bound']),
        'q25': np.percentile(result['off_targ_bound'], 25),
        'q75': np.percentile(result['off_targ_bound'], 75)
    }
    
    print(f"{combo_name}:")
    print(f"  Target cells (n={targ_stats['n']}): mean={targ_stats['mean']:.3f}, std={targ_stats['std']:.3f}, median={targ_stats['median']:.3f}")
    print(f"                     Q1-Q3: [{targ_stats['q25']:.3f}, {targ_stats['q75']:.3f}]")
    print(f"  Off-target cells (n={off_stats['n']}): mean={off_stats['mean']:.3f}, std={off_stats['std']:.3f}, median={off_stats['median']:.3f}")  
    print(f"                        Q1-Q3: [{off_stats['q25']:.3f}, {off_stats['q75']:.3f}]")
    print(f"  Selectivity (mean ratio): {targ_stats['mean']/off_stats['mean']:.3f}")
    print()
```

## Parameter Summary

```{python}
#| output: asis

text = f"""
Analyzed bound {signal_receptor} (signal receptor) distributions for **{targ_cell}** target cells vs off-target cells across **{len(receptor_combinations)}** receptor combinations with explicit valency specifications.

**Key Design Features:**
- **Explicit valency specification** for each combination to avoid valency errors
- All combinations use **2x {signal_receptor}** as signal receptor for consistency
- Single receptor combinations: bivalent targeting (2x targeting receptor)  
- Dual receptor combinations: monovalent targeting (1x each targeting receptor)
- Dose: **{dose}** M
- Sample size: **{sample_size}** cells (**{np.sum(targ_mask)}** target, **{np.sum(off_targ_mask)}** off-target)

**Valency Specifications:**
{chr(10).join([f"- {'+'.join(combo[0])} → [{', '.join(map(str, combo[1][0]))}] → {combo[2]}" for combo in receptor_combinations])}

**Analysis Focus:**
The visualization clearly shows the distributions of bound signal receptors that directly feed into the selectivity metric calculation:
- **Selectivity = Target Mean Binding / Off-target Mean Binding**
- Distributions reveal the heterogeneity masked by mean-based selectivity calculations
- Violin plots show full distribution shapes, not just summary statistics
- Each combination uses explicitly defined valencies to ensure correct binding model calculations

This analysis reveals how population-level heterogeneity affects the interpretation of selectivity metrics with proper valency control.
"""

print(text)
```
